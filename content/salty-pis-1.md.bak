Title: Salty Pi's Part 1
Date: 2017-09-16 00:00
Tags:  raspberry pi, salt


## Vagrant
For now I am going to use a Vagrant VM instead of a dedicated salt master. My reason for now is that salt provisioning is [built in](https://www.vagrantup.com/docs/provisioning/salt.html) to Vagrant which makes getting setup very easy. Also as long as I keep the configuration files I can redeploy the master to another device such as another Pi or a dedicated server. 

Because Salt is handled automatically we just need a simple Vagrant file such as this one, which I have commented accordingly, as an example:

    :::ruby
    # -*- mode: ruby -*-
    # vi: set ft=ruby :

    Vagrant.configure(2) do |config|
      # Using the Centos V7 As the base image
      config.vm.box = "centos/7"

      # This will always be my salt master on my network
      config.vm.network "public_network", ip: "192.168.1.200"
      config.vm.host_name = "salt"

      # Define some specific virtualbox settings. If you use a different VM provider you will
      # need to adjust accordingly.
      config.vm.provider "virtualbox" do |vb|
        vb.memory = "512" 
        vb.cpus = 1
        vb.name = "salt" # Hostname
      end

      # Salt configuration
      # The /srv/salt directory is where most configurations are stored in salt
      # and we want to access from outside the vm.  This will allow one to reuse it
      # and redeploy it in the future.
      config.vm.synced_folder "saltstack/salt", "/srv/salt"
      config.vm.synced_folder "saltstack/pillar", "/srv/pillar"

      # Here we define how salt is configured using the built in salt provisionery
      config.vm.provision :salt do |salt|
        # This will be a master node
        salt.install_master = true
        # Use the stable saltstack version
        salt.install_type = "stable"

        # Other configurations settings.
        salt.verbose = true
        salt.colorize = true
        salt.bootstrap_options = "-P -c /tmp"
      end
    end

> Note: Please make sure you have a recent version of Vagrant installed.  Do not rely on your package managers version which may be out of date.  Please go to to the [Vagrant downloads](https://www.vagrantup.com/downloads.html) page and find the appropriate download.
> Also, if you are using the virtualbox vm provider make sure the vbguest plugin is installed. `vagrant plugin install vagrant-vbguest`

Create the salt and pillar directories then start the vm. 

    $ mkdir -p saltstack/{salt,pillar}
    $ vagrant up

Once everything is built and running we can login and sudo to root.
    
    :::bash
    $ vagrant ssh
    $ sudo su - 

The way the master-minion system works here is pretty simple.  Essentially the master sits on the network at hostname `salt` and waits for minions to try and connect, including itself.  By default the minions will not be allowed to connected until an 'key' has been accepted by the master. Because we haven't pre-seeded these keys the master has not accepted itself, so we will do that real quick. As root you can list all the keys as follows.

    :::bash
    $ salt-key -L
        Accepted Keys:
        Denied Keys:
        Unaccepted Keys:
        salt
        Rejected Keys:

As we can see there is an unaccepted key here.  We can just accept all the keys by using the `-A` option since we know where it is coming from in this instance.  In the future we will need to be careful about blindly accepting any keys. 

    :::bash
    $ salt-key -A
        Unaccepted Keys:
        salt
        Proceed? [n/Y] y
        Key for minion salt accepted.

Ok, now that we have salt installed and configured we can test it out using the test.ping module in salt.

    :::bash
    $ salt '*' test.ping
        salt:
            True

And there we go! We have a working salt master to play with now.  We can now start adding state and pillar files into our saltstack directory. For more information on running salt visit the main saltstack [documentation](https://docs.saltstack.com/en/latest/contents.html)

Stay tuned for Parts 2 and 3!
